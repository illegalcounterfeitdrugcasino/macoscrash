<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE Stress Test - System Destroyer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0000 100%);
            color: #fff;
        }
        @keyframes danger-pulse {
            0%, 100% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.6); }
            50% { box-shadow: 0 0 60px rgba(239, 68, 68, 1); }
        }
        .danger-glow {
            animation: danger-pulse 1.5s ease-in-out infinite;
        }
        input[type="radio"]:checked + label {
            border-color: #ef4444;
            background-color: #7f1d1d;
        }
        .stat-card {
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.8) 0%, rgba(50, 20, 20, 0.8) 100%);
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <canvas id="glCanvas" class="hidden w-0 h-0"></canvas>

    <div class="w-full max-w-5xl bg-gray-900/90 border-2 border-red-900 rounded-2xl shadow-2xl backdrop-blur-sm overflow-hidden danger-glow">
        <div class="p-6 border-b-2 border-red-900 bg-gradient-to-r from-red-950 to-gray-900">
            <h1 class="text-3xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-red-500 via-orange-500 to-red-600">
                ‚ò†Ô∏è ULTIMATE SYSTEM DESTROYER
            </h1>
            <p class="text-red-300 mt-2 text-sm md:text-base font-bold">
                ‚ö†Ô∏è EXTREME WARNING: This WILL crash your device. May cause permanent thermal damage, data loss, or system failure.
            </p>
            <div id="gpuInfo" class="mt-3 p-3 bg-black/50 rounded-lg text-xs text-gray-300 font-mono">
                Detecting GPU capabilities...
            </div>
        </div>

        <div class="p-6 md:p-8 space-y-6">
            <!-- Test Mode Selection -->
            <div>
                <fieldset>
                    <legend class="text-red-400 font-bold mb-3 text-xl uppercase tracking-wider">Destruction Mode:</legend>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        <div>
                            <input type="radio" name="testMode" value="massive" id="modeMassive" class="hidden">
                            <label for="modeMassive" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-gray-700 rounded-lg transition-all hover:border-red-600">
                                <span class="font-bold text-red-400 text-lg">üî• MASSIVE TRANSFERS</span>
                                <span class="block text-xs text-gray-400 mt-1">Huge chunks at maximum size</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" name="testMode" value="constant" id="modeConstant" class="hidden">
                            <label for="modeConstant" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-gray-700 rounded-lg transition-all hover:border-red-600">
                                <span class="font-bold text-orange-400 text-lg">‚ö° CONSTANT BARRAGE</span>
                                <span class="block text-xs text-gray-400 mt-1">Rapid-fire tiny transfers</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" name="testMode" value="benchmark" id="modeBench" class="hidden" checked>
                            <label for="modeBench" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-gray-700 rounded-lg transition-all hover:border-red-600">
                                <span class="font-bold text-yellow-400 text-lg">üìä BENCHMARK (PROVEN)</span>
                                <span class="block text-xs text-gray-400 mt-1">The iPhone killer - shader intensive</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" name="testMode" value="nuclear" id="modeNuclear" class="hidden">
                            <label for="modeNuclear" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-red-700 rounded-lg transition-all hover:border-red-500">
                                <span class="font-bold text-red-500 text-lg">‚ò¢Ô∏è NUCLEAR MELTDOWN</span>
                                <span class="block text-xs text-gray-400 mt-1">Maximum texture + infinite ops</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" name="testMode" value="cascade" id="modeCascade" class="hidden">
                            <label for="modeCascade" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-purple-700 rounded-lg transition-all hover:border-purple-500">
                                <span class="font-bold text-purple-400 text-lg">üåä CASCADE OVERLOAD</span>
                                <span class="block text-xs text-gray-400 mt-1">Multiple textures in parallel</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" name="testMode" value="custom" id="modeCustom" class="hidden">
                            <label for="modeCustom" class="cursor-pointer block p-4 bg-gray-800/50 border-2 border-gray-700 rounded-lg transition-all hover:border-cyan-600">
                                <span class="font-bold text-cyan-400 text-lg">‚öôÔ∏è CUSTOM CHAOS</span>
                                <span class="block text-xs text-gray-400 mt-1">Fine-tune your destruction</span>
                            </label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- Multiplier Control -->
            <div>
                <label class="text-red-400 font-bold mb-2 block uppercase tracking-wider">Intensity Multiplier: <span id="multiplierValue" class="text-white">1x</span></label>
                <input type="range" id="multiplier" min="1" max="1000" value="1" class="w-full h-3 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-red-600">
                <div class="flex justify-between text-xs text-gray-500 mt-1">
                    <span>1x</span>
                    <span>250x</span>
                    <span>500x</span>
                    <span>750x</span>
                    <span>1000x (DEATH)</span>
                </div>
                <div class="mt-3 flex items-center gap-3">
                    <label class="text-gray-300 text-sm">Custom multiplier:</label>
                    <input type="number" id="customMultiplier" min="1" max="999999" placeholder="1-999999" class="px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white w-32 focus:outline-none focus:border-red-500">
                    <button id="applyCustomMultiplier" class="px-4 py-2 bg-red-700 hover:bg-red-600 text-white font-semibold rounded-lg text-sm">Apply</button>
                </div>
            </div>

            <!-- CPU Stress Toggle -->
            <div class="p-4 bg-gradient-to-r from-purple-950/50 to-pink-950/50 border-2 border-purple-700 rounded-lg">
                <div class="flex items-center gap-3">
                    <input type="checkbox" id="cpuStress" class="w-5 h-5 accent-purple-600 cursor-pointer">
                    <label for="cpuStress" class="text-purple-300 font-bold text-lg cursor-pointer flex-1">
                        üíÄ ENABLE CPU DESTRUCTION (Activates 5s after GPU start)
                    </label>
                </div>
                <p class="text-purple-200 text-xs mt-2 ml-8">
                    Spawns unlimited worker threads performing cryptographic hashing, prime calculations, and infinite loops. WILL FREEZE YOUR DEVICE.
                </p>
            </div>

            <!-- Custom Mode Settings -->
            <div id="customSettings" class="hidden space-y-4 p-4 bg-black/30 rounded-lg border border-cyan-700">
                <div>
                    <label class="text-cyan-300 font-semibold mb-2 block">Transfer Size:</label>
                    <input type="range" id="customSize" min="1" max="100" value="100" class="w-full h-2 bg-gray-700 rounded-lg accent-cyan-600">
                    <div class="text-xs text-gray-400 mt-1">Size: <span id="customSizeVal">100%</span> of max texture</div>
                </div>
                <div>
                    <label class="text-cyan-300 font-semibold mb-2 block">Operations per Frame:</label>
                    <input type="range" id="customOps" min="1" max="10000" value="1000" class="w-full h-2 bg-gray-700 rounded-lg accent-cyan-600">
                    <div class="text-xs text-gray-400 mt-1">Ops: <span id="customOpsVal">1000</span></div>
                </div>
            </div>

            <!-- Stats Display -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                <div class="stat-card p-3 rounded-lg border border-gray-700">
                    <div class="text-gray-400 text-xs uppercase">Frames</div>
                    <div id="frameCount" class="text-2xl font-bold text-white">0</div>
                </div>
                <div class="stat-card p-3 rounded-lg border border-gray-700">
                    <div class="text-gray-400 text-xs uppercase">GPU Ops</div>
                    <div id="opCount" class="text-2xl font-bold text-red-400">0</div>
                </div>
                <div class="stat-card p-3 rounded-lg border border-gray-700">
                    <div class="text-gray-400 text-xs uppercase">Data Moved</div>
                    <div id="dataCount" class="text-2xl font-bold text-orange-400">0 GB</div>
                </div>
                <div class="stat-card p-3 rounded-lg border border-gray-700">
                    <div class="text-gray-400 text-xs uppercase">FPS</div>
                    <div id="fpsCount" class="text-2xl font-bold text-yellow-400">--</div>
                </div>
                <div class="stat-card p-3 rounded-lg border border-purple-700 col-span-2">
                    <div class="text-purple-400 text-xs uppercase">CPU Workers</div>
                    <div id="cpuWorkers" class="text-2xl font-bold text-purple-300">0</div>
                </div>
                <div class="stat-card p-3 rounded-lg border border-purple-700 col-span-2">
                    <div class="text-purple-400 text-xs uppercase">CPU Operations</div>
                    <div id="cpuOps" class="text-2xl font-bold text-purple-300">0</div>
                </div>
            </div>

            <!-- Status -->
            <div>
                <div class="text-gray-300 font-semibold mb-2 flex items-center gap-2">
                    Status: <span id="statusText" class="text-white">Ready to destroy your device</span>
                    <span id="loadingSpinner" class="hidden">
                        <svg class="animate-spin h-5 w-5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </span>
                </div>
                <div class="h-4 w-full bg-gray-800 rounded-full overflow-hidden border border-gray-700">
                    <div id="progressBar" class="h-full w-0 bg-gradient-to-r from-red-600 to-orange-600 transition-all duration-300"></div>
                </div>
            </div>

            <!-- Control Buttons -->
            <div class="flex gap-3">
                <button id="startBtn" class="flex-1 px-6 py-4 bg-red-600 hover:bg-red-500 active:bg-red-700 text-white font-bold rounded-xl transition-all shadow-lg shadow-red-500/30 text-lg">
                    üöÄ INITIATE DESTRUCTION
                </button>
                <button id="stopBtn" class="hidden flex-1 px-6 py-4 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-xl transition-all">
                    ‚èπÔ∏è STOP (if you can...)
                </button>
            </div>

            <div class="p-4 bg-red-900/30 border-2 border-red-600 rounded-lg text-red-200 text-xs">
                <strong>üö® CRITICAL WARNING:</strong> This tool is designed to CRASH your device. It WILL cause extreme heat, lag, freezing, and potentially permanent damage. 
                Use only on devices you're willing to sacrifice. Monitor temperatures constantly. We are NOT responsible for ANY damage.
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('glCanvas');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusText = document.getElementById('statusText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const progressBar = document.getElementById('progressBar');
        const gpuInfo = document.getElementById('gpuInfo');
        const frameCount = document.getElementById('frameCount');
        const opCount = document.getElementById('opCount');
        const dataCount = document.getElementById('dataCount');
        const fpsCount = document.getElementById('fpsCount');
        const cpuWorkers = document.getElementById('cpuWorkers');
        const cpuOps = document.getElementById('cpuOps');
        const multiplierValue = document.getElementById('multiplierValue');
        const customSettings = document.getElementById('customSettings');
        const customSizeVal = document.getElementById('customSizeVal');
        const customOpsVal = document.getElementById('customOpsVal');

        // WebGL Globals
        let gl = null;
        let maxTexSize = 0;
        let isRunning = false;
        let shouldStop = false;
        let animationId = null;
        
        // Stats
        let frames = 0;
        let operations = 0;
        let totalGBMoved = 0;
        let lastFpsTime = 0;
        let framesSinceFps = 0;
        let cpuWorkerCount = 0;
        let cpuOperations = 0;

        // Test resources
        let textures = [];
        let framebuffers = [];
        let shaderProgram = null;
        let quadBuffer = null;
        let workers = [];

        // Detect GPU capabilities
        function detectGPU() {
            try {
                const tempCanvas = document.createElement('canvas');
                gl = tempCanvas.getContext('webgl', { 
                    antialias: false,
                    powerPreference: 'high-performance'
                });
                
                if (!gl) throw new Error("WebGL not supported");
                
                maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const renderer = gl.getParameter(gl.RENDERER);
                const vendor = gl.getParameter(gl.VENDOR);
                
                gpuInfo.innerHTML = `
                    <strong>GPU Detected:</strong> ${renderer}<br>
                    <strong>Vendor:</strong> ${vendor}<br>
                    <strong>Max Texture Size:</strong> ${maxTexSize}x${maxTexSize} (${(maxTexSize * maxTexSize * 4 / 1024 / 1024 / 1024).toFixed(2)} GB per texture)
                `;
                
                const ext = gl.getExtension('WEBGL_lose_context');
                if (ext) ext.loseContext();
                
            } catch (e) {
                gpuInfo.innerHTML = `<span class="text-red-400">‚ùå Error: ${e.message}</span>`;
            }
        }

        // Setup WebGL
        function setupWebGL() {
            gl = canvas.getContext('webgl', { 
                antialias: false,
                powerPreference: 'high-performance',
                preserveDrawingBuffer: false
            });
            
            if (!gl) throw new Error('WebGL not available');
            
            // Setup shaders
            const vsSource = `
                attribute vec2 a_position;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_position * 0.5 + 0.5;
                }
            `;
            
            const fsSource = `
                precision highp float;
                uniform sampler2D u_texture;
                varying vec2 v_texCoord;
                uniform float u_time;
                
                void main() {
                    vec4 color = texture2D(u_texture, v_texCoord);
                    float noise = sin(v_texCoord.x * 100.0 + u_time) * cos(v_texCoord.y * 100.0 + u_time);
                    gl_FragColor = vec4(color.rgb * (1.0 + noise * 0.1), color.a);
                }
            `;
            
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                throw new Error('Shader program failed');
            }
            
            // Setup quad
            quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const posLoc = gl.getAttribLocation(shaderProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.useProgram(shaderProgram);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('Shader compile error');
            }
            return shader;
        }

        function createTexture(size) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
        }

        // CPU Destruction
        function startCPUDestruction() {
            const workerCode = `
                let ops = 0;
                function infiniteWork() {
                    // Cryptographic-style calculations
                    let hash = 0;
                    for (let i = 0; i < 100000; i++) {
                        hash = ((hash << 5) - hash) + i;
                        hash = hash & hash;
                        Math.sqrt(hash);
                        Math.sin(hash);
                        Math.cos(hash);
                    }
                    
                    // Prime calculations
                    for (let i = 2; i < 10000; i++) {
                        let isPrime = true;
                        for (let j = 2; j < Math.sqrt(i); j++) {
                            if (i % j === 0) isPrime = false;
                        }
                    }
                    
                    ops += 100000;
                    postMessage(ops);
                    infiniteWork();
                }
                infiniteWork();
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            
            // Spawn many workers (intentionally excessive)
            const numWorkers = navigator.hardwareConcurrency ? navigator.hardwareConcurrency * 4 : 16;
            
            for (let i = 0; i < numWorkers; i++) {
                try {
                    const worker = new Worker(workerUrl);
                    worker.onmessage = (e) => {
                        cpuOperations += 100000;
                    };
                    workers.push(worker);
                    cpuWorkerCount++;
                } catch (e) {
                    console.error('Worker spawn failed:', e);
                }
            }
            
            // Also run infinite loops in main thread
            let mainThreadOps = 0;
            const mainThreadWork = () => {
                for (let i = 0; i < 100000; i++) {
                    Math.sqrt(Math.random() * 999999);
                    Math.sin(i) * Math.cos(i);
                }
                mainThreadOps += 100000;
                cpuOperations += 100000;
                if (!shouldStop) setTimeout(mainThreadWork, 0);
            };
            
            // Spawn multiple main thread loops
            for (let i = 0; i < 4; i++) {
                setTimeout(mainThreadWork, 0);
            }
        }

        // Massive Transfers Mode
        async function runMassiveMode(multiplier) {
            const size = Math.floor(maxTexSize * 0.95);
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            const tex1 = createTexture(size);
            const tex2 = createTexture(size);
            const fbo = gl.createFramebuffer();
            
            textures.push(tex1, tex2);
            framebuffers.push(fbo);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            
            statusText.textContent = `MASSIVE MODE: ${size}x${size} @ ${multiplier}x`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                for (let i = 0; i < multiplier; i++) {
                    gl.uniform1f(timeLoc, performance.now() / 1000);
                    gl.bindTexture(gl.TEXTURE_2D, tex1);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    operations++;
                    totalGBMoved += gbPerOp;
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        // Constant Barrage Mode
        async function runConstantMode(multiplier) {
            const size = 512;
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            const tex1 = createTexture(size);
            const tex2 = createTexture(size);
            const fbo = gl.createFramebuffer();
            
            textures.push(tex1, tex2);
            framebuffers.push(fbo);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            const opsPerFrame = 200 * multiplier;
            statusText.textContent = `BARRAGE: ${opsPerFrame} ops/frame`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                gl.uniform1f(timeLoc, performance.now() / 1000);
                
                for (let i = 0; i < opsPerFrame; i++) {
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    operations++;
                    totalGBMoved += gbPerOp;
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        // Benchmark Style Mode (The proven iPhone killer)
        async function runBenchmarkMode(multiplier) {
            const size = Math.min(8192, maxTexSize);
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            const tex1 = createTexture(size);
            const tex2 = createTexture(size);
            const fbo = gl.createFramebuffer();
            
            textures.push(tex1, tex2);
            framebuffers.push(fbo);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            const opsPerFrame = 1000 * multiplier;
            statusText.textContent = `BENCHMARK: ${size}x${size}, ${opsPerFrame.toLocaleString()} ops/frame`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                gl.uniform1f(timeLoc, performance.now() / 1000);
                
                for (let i = 0; i < opsPerFrame; i++) {
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    operations++;
                    totalGBMoved += gbPerOp;
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        // Nuclear Meltdown Mode
        async function runNuclearMode(multiplier) {
            const size = Math.floor(maxTexSize * 0.99);
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            const tex1 = createTexture(size);
            const tex2 = createTexture(size);
            const fbo = gl.createFramebuffer();
            
            textures.push(tex1, tex2);
            framebuffers.push(fbo);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            const opsPerFrame = 5000 * multiplier;
            statusText.textContent = `‚ò¢Ô∏è NUCLEAR: ${size}x${size}, ${opsPerFrame.toLocaleString()} ops/frame`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                gl.uniform1f(timeLoc, performance.now() / 1000);
                
                for (let i = 0; i < opsPerFrame; i++) {
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    operations++;
                    totalGBMoved += gbPerOp;
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        // Cascade Overload Mode
        async function runCascadeMode(multiplier) {
            const size = Math.min(4096, maxTexSize);
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            // Create multiple texture pairs
            const numPairs = 8;
            for (let i = 0; i < numPairs; i++) {
                const tex1 = createTexture(size);
                const tex2 = createTexture(size);
                const fbo = gl.createFramebuffer();
                
                textures.push(tex1, tex2);
                framebuffers.push(fbo);
            }
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            const opsPerFrame = 500 * multiplier;
            statusText.textContent = `üåä CASCADE: ${numPairs} textures @ ${size}x${size}, ${opsPerFrame.toLocaleString()} ops/frame`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                gl.uniform1f(timeLoc, performance.now() / 1000);
                
                // Cycle through all texture pairs
                for (let pair = 0; pair < numPairs; pair++) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[pair]);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[pair * 2 + 1], 0);
                    gl.bindTexture(gl.TEXTURE_2D, textures[pair * 2]);
                    
                    for (let i = 0; i < opsPerFrame / numPairs; i++) {
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        operations++;
                        totalGBMoved += gbPerOp;
                    }
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        // Custom Mode
        async function runCustomMode(multiplier) {
            const sizePercent = parseInt(document.getElementById('customSize').value);
            const opsPerFrame = parseInt(document.getElementById('customOps').value) * multiplier;
            
            const size = Math.floor(maxTexSize * (sizePercent / 100));
            const bytesPerOp = size * size * 4;
            const gbPerOp = bytesPerOp / (1024 * 1024 * 1024);
            
            canvas.width = size;
            canvas.height = size;
            gl.viewport(0, 0, size, size);
            
            const tex1 = createTexture(size);
            const tex2 = createTexture(size);
            const fbo = gl.createFramebuffer();
            
            textures.push(tex1, tex2);
            framebuffers.push(fbo);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            
            const timeLoc = gl.getUniformLocation(shaderProgram, 'u_time');
            statusText.textContent = `CUSTOM: ${size}x${size}, ${opsPerFrame.toLocaleString()} ops/frame`;
            
            const renderFrame = () => {
                if (shouldStop) return;
                
                gl.uniform1f(timeLoc, performance.now() / 1000);
                
                for (let i = 0; i < opsPerFrame; i++) {
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    operations++;
                    totalGBMoved += gbPerOp;
                }
                
                frames++;
                updateStats();
                progressBar.style.width = '100%';
                
                animationId = requestAnimationFrame(renderFrame);
            };
            
            renderFrame();
        }

        function updateStats() {
            frameCount.textContent = frames.toLocaleString();
            opCount.textContent = operations.toLocaleString();
            dataCount.textContent = totalGBMoved.toFixed(2) + ' GB';
            cpuWorkers.textContent = cpuWorkerCount;
            cpuOps.textContent = cpuOperations.toLocaleString();
            
            const now = performance.now();
            framesSinceFps++;
            
            if (now - lastFpsTime >= 1000) {
                const fps = Math.round(framesSinceFps / ((now - lastFpsTime) / 1000));
                fpsCount.textContent = fps;
                lastFpsTime = now;
                framesSinceFps = 0;
            }
        }

        function cleanup() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Terminate all CPU workers
            workers.forEach(worker => worker.terminate());
            workers = [];
            cpuWorkerCount = 0;
            
            textures.forEach(tex => gl.deleteTexture(tex));
            framebuffers.forEach(fbo => gl.deleteFramebuffer(fbo));
            textures = [];
            framebuffers = [];
            
            if (gl) {
                const ext = gl.getExtension('WEBGL_lose_context');
                if (ext) ext.loseContext();
                gl = null;
            }
        }

        async function startTest() {
            if (isRunning) return;
            
            isRunning = true;
            shouldStop = false;
            frames = 0;
            operations = 0;
            totalGBMoved = 0;
            cpuOperations = 0;
            lastFpsTime = performance.now();
            framesSinceFps = 0;
            
            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            loadingSpinner.classList.remove('hidden');
            
            try {
                setupWebGL();
                
                const mode = document.querySelector('input[name="testMode"]:checked').value;
                const multiplier = parseInt(document.getElementById('multiplier').value);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Start GPU stress
                if (mode === 'massive') await runMassiveMode(multiplier);
                else if (mode === 'constant') await runConstantMode(multiplier);
                else if (mode === 'benchmark') await runBenchmarkMode(multiplier);
                else if (mode === 'nuclear') await runNuclearMode(multiplier);
                else if (mode === 'cascade') await runCascadeMode(multiplier);
                else if (mode === 'custom') await runCustomMode(multiplier);
                
                // Start CPU stress after 5 seconds if enabled
                if (document.getElementById('cpuStress').checked) {
                    setTimeout(() => {
                        if (!shouldStop) {
                            statusText.textContent += ' | üíÄ CPU DESTRUCTION ACTIVE';
                            startCPUDestruction();
                        }
                    }, 5000);
                }
                
            } catch (e) {
                statusText.textContent = 'Error: ' + e.message;
                stopTest();
            }
        }

        function stopTest() {
            shouldStop = true;
            isRunning = false;
            
            cleanup();
            
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            loadingSpinner.classList.add('hidden');
            statusText.textContent = 'Test stopped';
            progressBar.style.width = '0%';
        }

        // Event Listeners
        startBtn.addEventListener('click', startTest);
        stopBtn.addEventListener('click', stopTest);
        
        document.getElementById('multiplier').addEventListener('input', (e) => {
            multiplierValue.textContent = e.target.value + 'x';
        });
        
        document.getElementById('applyCustomMultiplier').addEventListener('click', () => {
            const customVal = parseInt(document.getElementById('customMultiplier').value);
            if (customVal && customVal >= 1 && customVal <= 999999) {
                document.getElementById('multiplier').value = customVal;
                multiplierValue.textContent = customVal + 'x';
            }
        });
        
        document.querySelectorAll('input[name="testMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    customSettings.classList.remove('hidden');
                } else {
                    customSettings.classList.add('hidden');
                }
            });
        });
        
        document.getElementById('customSize').addEventListener('input', (e) => {
            customSizeVal.textContent = e.target.value + '%';
        });
        
        document.getElementById('customOps').addEventListener('input', (e) => {
            customOpsVal.textContent = e.target.value;
        });

        // Initialize
        detectGPU();
    </script>
</body>
</html>
